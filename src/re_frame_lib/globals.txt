Files and global variables on files. They can have an status like:
'in' to include them in the compound state, 'out' to leave as it is, 'rem' to
remove them.

db.cljc
- app-db            (app database ratom)

events.cljc
- *handling*        (currently handled event)
- handle            (fn that use a global)

interop.cljs
- executor              
- on-dispose-callbacks
out - next-tick
out - empty-queue       (sample of queue)
out - after-render
- debug-enabled?

+ We should put all state creation here.

loggers.cljc    DONE
- loggers           -

registrar.cljs      DONE
- kind->id->handler (subscriptions)

router.cljc
out??- later-fns
- event-queue       (events and state machine for event queueing)

trace.cljc
- id
- *current-trace*
- trace-enabled

* extra
poshX
- store             (store for a posh!ed datascript database)


----------------------------------------------

The focus and purpose of this mooding is to make easier testing and composition
of ui components.

General process to use a compound re-frame state to be a library instead of a
framework.



(def rfs    ; re-frame state
  (-> (new-state X Y Z)
      (reg-APP-subscription)        ; use (reg-sub rfs :subs-name ...)
      (reg-APP-events)              ; use (reg-event-db rfs :evt-name ...)
      (reg-APP-configurations)))    ; use other stuff.



(dispatch rfs [:event X Y Z])
(subscribe rfs [:subscription X Y Z])

The re-frame state should be a simple hash-map that points to other objects or
atoms/ratoms. That is all. Maybe one can use it wrap it in a atom/ratom to use
it with Devcards, but in general the user interface components should relay on
a simple hash-map re-frame state to do all their machinery.

This change may break many code that relies on adding/removing subscriptions.
That may work but it is not the focus now.

